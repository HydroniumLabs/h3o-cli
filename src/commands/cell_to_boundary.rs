//! Expose [`CellIndex::boundary`]

use anyhow::Result as AnyResult;
use clap::{Parser, ValueEnum};
use geojson::{FeatureCollection, GeoJson};
use h3o::CellIndex;
use kml::Kml;

/// Converts indexes to latitude/longitude cell boundaries in degrees.
///
/// This command reads H3 indexes from stdin and outputs the corresponding cell
/// boundaries to stdout, until EOF is encountered.
#[derive(Parser, Debug)]
pub struct Args {
    /// Cell index.
    #[arg(short, long)]
    index: Option<CellIndex>,

    /// Output format.
    #[arg(short, long, value_enum, default_value_t = Format::Text)]
    format: Format,
}

#[derive(Debug, Copy, Clone, PartialEq, Eq, ValueEnum)]
enum Format {
    Text,
    Geojson,
    Kml,
}

/// Run the `cellToBoundary` command.
pub fn run(args: &Args) -> AnyResult<()> {
    let indexes = if let Some(index) = args.index {
        vec![index]
    } else {
        crate::io::read_cell_indexes()?
    };
    print_cell_boundaries(&indexes, args.format)?;

    Ok(())
}

fn print_cell_boundaries(
    indexes: &[CellIndex],
    format: Format,
) -> AnyResult<()> {
    match format {
        Format::Text => boundaries_to_text(indexes),
        Format::Geojson => boundaries_to_geojson(indexes),
        Format::Kml => boundaries_to_kml(indexes)?,
    }

    Ok(())
}

/// Print boundaries as plain text.
fn boundaries_to_text(indexes: &[CellIndex]) {
    for index in indexes {
        println!("{index}");
        println!("{{");
        for ll in index.boundary().iter() {
            println!("   {:.9} {:.9}", ll.lat_degrees(), ll.lng_degrees());
        }
        println!("}}");
    }
}

/// Print boundaries as geojson.
fn boundaries_to_geojson(indexes: &[CellIndex]) {
    let features = crate::geojson::boundaries(indexes);
    let geojson = GeoJson::FeatureCollection(FeatureCollection {
        bbox: None,
        features,
        foreign_members: None,
    });

    println!("{geojson}");
}

/// Print boundaries as KML.
fn boundaries_to_kml(indexes: &[CellIndex]) -> AnyResult<()> {
    let style_id = "lineStyle1";
    let style = kml::types::Style {
        id: style_id.to_owned(),
        line: Some(kml::types::LineStyle {
            id: "lineStyle2".to_owned(),
            color: "ff0000ff".to_owned(),
            width: 2.,
            ..kml::types::LineStyle::default()
        }),
        ..kml::types::Style::default()
    };

    let mut elements = vec![Kml::Style(style)];
    elements.append(&mut crate::kml::boundaries(indexes, style_id));

    crate::kml::print_document(
        "H3 Geometry".to_owned(),
        "Generated by cellToBoundary".to_owned(),
        elements,
    )
}
